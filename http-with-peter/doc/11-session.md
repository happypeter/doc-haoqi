# 会话 session

今天扯扯 session 也就是**会话**这个概念，这个概念其实有点模糊，不同语言和框架下对 session 的实现做法也不太一样，同时这个会话这个词也本身意思就比较宽泛，容易被外行泛用，例如我自己以前就认为，一次会话就是以我在浏览器里面打开网址为开始，然后以我关闭这个网站的那个时刻作为结束，显然这个想法是太肤浅了。

网上要是看 session 相关的资料，发现各家说法都不太一样。Peter 这里给出我认为比较通用的一种理解。理解了我说的 session 的概念，后面再看**会话过期**，或者**会话劫持**这些概念就会比较好懂了。

### 什么是会话？

我自己的理解就是：

>会话就是服务器和浏览器的保有共同的一些小秘密的这段时间

换句话，会话开始和结束，就意味着服务器从认识一个浏览器到不再认识这个浏览器。

### 实现会话的技术机制

方法不唯一，最常见的一个方式是这样：

- 第一步，准备建立会话的时候，服务器会在自己的内存里创建一个新的变量，例如这个变量叫做 session-3254 ，
- 第二步，服务器把这个会话的 id 也就是 3254 发送到我的浏览器，浏览器会把这个 id 保存到 cookie 中
- 之后，每次我的浏览器再去访问服务器的时候，都会携带 cookie 中存放的 3254 这个会话 id 值，这样浏览器就认识
  这个浏览器了
- 服务器端的 session-3254 变量中可以存放任意的会话数据，例如：我的用户名，我购物车里有哪几件商品等等
- 每次浏览器访问服务器，都可以凭借自己的会话 id 去服务器的 session-3254 变量中去认领属于我的信息

每一个请求都会包含这个会话 id ，这样服务器就能唯一确认你这个客户端啦。 这样，直到会话过期，客户端和服务器都是互相认识的，都保有一些共同的小秘密。

### 会话的意义

说的抽象点：会话可以让无状态的 HTTP 协议保持特定的状态。

这种在客户端与服务器之间传递**会话 id**的机制，能让服务器创建一种各次请求之间的持续连接状态。Web 开发人员利用这种人造的状态，来构建一些”有状态“的应用场景：例如用户处于一直登陆的状态，购物车里面之前添加的商品，后续访问中还有等等。

不过即使这样，每一个 HTTP 请求本质上来说还是无状态的，各次请求之间并不知道彼此的存在。

### 会话数据存在哪里？

一句话：服务器上的某个地方。

前面我说是在内存里，但其实有的时候，可能会存在某个持久化存储介质上，比如数据库或者键 / 值存储。会话数据存在哪里不是我们现在需要关心的。现在重要的是要理解会话 id 存储在客户端，它是访问存储在服务器上的会话数据的 “钥匙”。

### 会话过期

服务器上有多少个浏览器在访问，就会在自己内存中创建多少了类似 session-3254 这样的变量。但是，还有一点非常重要，在一个会话里发出的会话 id 是唯一的，而且有一个很短的过期时间。那什么情况下会话就会过期呢？

- 手动删掉 cookie 中的会话 id （在 chrome devtools 里，右键 cookies 然后删除它）
- 点一个网站的退出登录按钮
- 关闭网站有时候也通常能结束会话

当然，讨论到这里，会话过期的本质我们其实是知道的：用客户端 cookie 中的 id 找到服务器端对应的 session 了。

### 会话劫持（ Session Hijacking ）

会话 id 作为一个唯一的令牌来唯一标识一个会话。通常，会话 id 是作为 cookie 存储在计算机上的一个随机字符串. 很多 web 应用的用户认证系统所在做的事情，当用户的用户名和密码匹配之后，会话 id 会存储在用户的浏览器里，这样我的下一个请求就不用重新认证了。

不幸的是，如果一个攻击者拿到了我的这个会话 id ，他就会跟我共享这一个会话，那服务器就会把他当成我，我的所有权限，
他都不需要知道我的用户名密码，都可以获得了。

防止会话劫持也是有方法的，这是个安全问题，我这里不细说了，总之就是用各种方法让当前会话 id 作废，然后重新创建新会话。

### 总结

会话的建立的确还是要结合具体的技术来讨论才会比较真实，我以前用 RubyOnRails ，它自己有一套现成的 session 管理方案，现在我写 Nodejs 使用 JWT 来建立**状态** ，其实跟我上面说的 session 的实现机制差别还是很大的。但是，我觉得
上面的这些内容还是所有开发者都有必要了解的一些通用的基础知识。所以写完本文我还挺有成就感的。
